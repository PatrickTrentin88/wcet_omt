#!/usr/bin/env python

import os, sys, argparse, errno, math, re, copy
import numpy as np
import matplotlib.pyplot as plt

###
### main
###

def main():
    opts = get_options()

    if len(opts.files) <= 0:
        print("usage: stats_plot [-n title] [-d plots_dir] [-t timeout] stats_file ...")
        quit(1)

    tools = []
    results = {}
    for file in opts.files:
        collect_stats(file, tools, results)

    if opts.d is not None:
        mkdir_p(opts.d)

    c_tools, c_results = collapse_stats(tools, results)
    for bench in c_results.keys():
        small_results = {}
        small_results[bench] = c_results[bench]
        name = opts.n + "_" + bench
        plot_bars(opts.d, name, c_tools, small_results, opts.t)
    
###
### help functions
###

def get_options():
    """parses and returns input options"""
    parser = argparse.ArgumentParser(description="stats_plot")
    parser.add_argument("-n", type=str, help="plot name", default="default")
    parser.add_argument("-d", type=str, help="plots directory", default=None)
    parser.add_argument("-t", type=int, help="timeout", default=600)
    parser.add_argument("files", type=str, nargs=argparse.REMAINDER)
    return parser.parse_args()

def collect_stats(file, tools, results):
    """parses statistics summary file generated by wcet_omt, saving
    the interesting values in 'tools' and 'results'"""
    try:
        with open(file, 'r') as fd:
            file = os.path.realpath(file)
            tool, ext = os.path.splitext(os.path.basename(file))
            if tool not in tools:
                tools.append(tool)

            idx = 0
            for line in fd:
                if idx != 0:
                    # parse line
                    max_path, opt_value, gain, num_cuts, \
                    real_time, status, timeout, errors, \
                    llvm_size, num_blocks, smt2_file, \
                    out_file = ''.join(line.split()).split("|")[1:-1]

                    bench, ext = os.path.splitext(os.path.basename(out_file))

                    if bench not in results.keys():
                        results[bench] = {}

                    results[bench][tool] = (float(real_time), 0, 0, 0)

                idx += 1

    except Exception as e:
        print("error: file `" + file + "` does not exist or cannot be read, quitting.\n")
        print e
        quit(1)

def collapse_stats(tools, results):
    """when omt tools are run multiple times with a different random seed, it collapses
    the collected data by merging those results that refer to the same benchmark together
    and computing useful statistics over it"""
    ret_results = {}
    ret_tools = []
    to_fix = {}

    pattern = re.compile("seed_([0-9]+)_(.*)")

    # collect data
    for key in results.keys():
        res = pattern.match(key)
        if res is None:
            ret_results[key] = results[key]
            for tool in results[key].keys():
                if tool not in ret_tools:
                    ret_tools.append(tool)
        else:
            seed  = res.group(1)
            bench = res.group(2)

            if bench not in to_fix.keys():
                to_fix[bench] = {}

            for tool in results[key].keys():
                if float(results[key][tool][0]) <= 0:
                    continue
                if tool not in to_fix[bench].keys():
                    to_fix[bench][tool] = []
                to_fix[bench][tool].append(float(results[key][tool][0]))

    # Compute Average
    for bench in to_fix.keys():
        if bench not in ret_results.keys():
            ret_results[bench] = {}
        for tool in to_fix[bench].keys():
            num_datapoints = len(to_fix[bench][tool])
            tool_name = tool + "_avg" + str(num_datapoints)
            if tool_name not in ret_tools:
                ret_tools.append(tool_name)
            values = to_fix[bench][tool]
            avg    = sum(values) / num_datapoints
            stddev = np.std(values)
            med    = np.median(values)
            perc   = np.percentile(map(float, values), 90)
            ret_results[bench][tool_name] = (avg, stddev, med, perc, 0)

    return ret_tools, ret_results

def plot_bars(plots_dir, title, tools, benchmarks, timeout):
    """ plots given benchmark data """
    #fig, ax = plt.subplots()
    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)

    # config

    axis_font = {'fontname' : 'Arial', 'size':'21', 'weight':'bold'}
    colors    = ('b', 'g', 'r', 'c', 'm', 'y', 'k', 'w')
    width     = 0.25
    num_bench = len(benchmarks.keys())
    l_space   = 0.10

    # plot data

    x_labels = benchmarks.keys()
    x_bars   = []
    x_vals   = []
    position = np.arange(num_bench) + l_space
    idx = 0
    for tool in tools:
        if "cuts" not in tool:
            y_vals = map(lambda bench: benchmarks[bench][tool][0] if tool in benchmarks[bench].keys() else -10, benchmarks.keys())
            stddev = map(lambda bench: benchmarks[bench][tool][1] if tool in benchmarks[bench].keys() else 0, benchmarks.keys())
            med    = map(lambda bench: benchmarks[bench][tool][2] if tool in benchmarks[bench].keys() else -10, benchmarks.keys())
            perc   = map(lambda bench: benchmarks[bench][tool][3] if tool in benchmarks[bench].keys() else -10, benchmarks.keys())
            if "avg" in tool:
                bar = ax.bar(position + (width + l_space) * idx, y_vals, width, color=colors[idx % len(colors)], label=tool, yerr=stddev, ecolor='r')
                ax.scatter(position + (width + l_space) * idx + width/2, med, color='k', zorder=3, marker='x')
                for pv in perc:
                    min = position + (width + l_space) * idx
                    max = position + (width + l_space) * idx + width
                    ax.hlines(pv, min, max, color='r', zorder=2)
            else:
                bar = ax.bar(position + (width + l_space) * idx, y_vals, width, color=colors[idx % len(colors)], label=tool)
            x_bars.append(bar)
            idx += 1
    for tool in tools:
        if "cuts" in tool:
            y_vals = map(lambda bench: benchmarks[bench][tool][0] if tool in benchmarks[bench].keys() else -10, benchmarks.keys())
            stddev = map(lambda bench: benchmarks[bench][tool][1] if tool in benchmarks[bench].keys() else 0, benchmarks.keys())
            med    = map(lambda bench: benchmarks[bench][tool][2] if tool in benchmarks[bench].keys() else -10, benchmarks.keys())
            perc   = map(lambda bench: benchmarks[bench][tool][3] if tool in benchmarks[bench].keys() else -10, benchmarks.keys())
            if "avg" in tool:
                bar = ax.bar(position + (width + l_space) * idx, y_vals, width, color=colors[idx % len(colors)], label=tool, yerr=stddev, ecolor='r')
                ax.scatter(position + (width + l_space) * idx + width/2, med, color='k', zorder=3, marker='x')
                for pv in perc:
                    min = position + (width + l_space) * idx
                    max = position + (width + l_space) * idx + width
                    ax.hlines(pv, min, max, color='r', zorder=2)
            else:
                bar = ax.bar(position + (width + l_space) * idx, y_vals, width, color=colors[idx % len(colors)], label=tool)
            x_bars.append(bar)
            idx += 1

    # axis config

    ax.grid(True)
    ax.set_title(title)

    ax.set_ylabel('time (s.)')
    ax.set_yscale('log', nonposy='clip')
    y_ticks = get_ticks(timeout)
    plt.ylim([0, timeout * 1.5])
    ax.set_yticks(y_ticks)
    ax.get_yaxis().get_major_formatter().labelOnlyBase = False

    ax.set_xticks(position + ((width + l_space) * idx) / 2)
    ax.set_xticklabels(x_labels)

    # legend

    x_bars_0s = map(lambda x: x[0], x_bars)
#    ax.legend(x_bars_0s, tools)

    for bar in x_bars:
        autolabel(ax, bar, timeout)

    lgd = plt.legend(loc=5, ncol=2, bbox_to_anchor=(1, -0.3))

    # timeout
    plt.axhline(y=timeout, color='r', zorder=4, linestyle='dashed')

    # save, show
    if plots_dir is not None:
        file_name = "%s/%s.png" % (plots_dir, title)
        plt.savefig(file_name, bbox_extra_artists=(lgd,), bbox_inches='tight')

#    plt.show()
    plt.close(fig)

def autolabel(ax, rects, timeout):
    """prints numeric value on top of each rect, '-/-' is used for missing data points"""
    for rect in rects:
        height = rect.get_height()
        y = rect.get_y()
        if y >= 0:
            if height >= timeout:
                ax.text(rect.get_x() + rect.get_width()/2., timeout * 1.05,
                    'TO',
                    ha='center', va='bottom', zorder=5)
            else:
                ax.text(rect.get_x() + rect.get_width()/2., timeout * 1.05,
                    '%.2f' % float(height),
                    ha='center', va='bottom', zorder=5)
        else:
            height = timeout
            ax.text(rect.get_x() + rect.get_width()/2., timeout * 1.05,
                '-/-',
                ha='center', va='bottom', zorder=5)

def get_ticks(timeout):
    x = []
    idx = 0
    max = int(math.log(timeout, 10))
    while (idx <= max):
        x.append(math.pow(10, idx))
        idx += 1
    return x

def mkdir_p(path):
    """make a directory and any missing ancestor if needed"""
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

###
###
###

if (__name__ == "__main__"):
    main()

###
###
###

# NOTE:
#   for debug reference, the following is an example of the
#   expected content of variables 'results' and 'tools' in this script
#
# results = {
#     'b1' : {
#         'z3' : 1200,
#         'optimathsat' : 100,
#         'smtopt' : 100,
#     },
#     'b2' : {
#        'z3' : 1200,
#         'smtopt' : 200,
#     },
#     'b3' : {
#         'z3' : 50,
#         'optimathsat' : 100,
#     },
# }
# 
# tools = ('z3', 'optimathsat', 'smtopt')
